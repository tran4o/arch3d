{
  "name": "q-connection",
  "version": "0.5.3",
  "description": "An inter-worker asynchronous promise communication system.",
  "homepage": "http://github.com/kriskowal/q-connection/",
  "author": {
    "name": "Kris Kowal",
    "email": "kris@cixar.com",
    "url": "http://github.com/kriskowal/"
  },
  "contributors": [
    {
      "name": "Kris Kowal",
      "email": "kris@cixar.com",
      "url": "http://github.com/kriskowal/"
    },
    {
      "name": "Irakli Gozalishvili",
      "email": "rfobic@gmail.com",
      "url": "http://jeditoolkit.com/"
    }
  ],
  "credits": [
    "Mark Miller <erights@google.com>"
  ],
  "bugs": {
    "url": "http://github.com/kriskowal/q-connection/issues"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "http://github.com/kriskowal/q-connection/raw/master/LICENSE"
    }
  ],
  "main": "q-connection.js",
  "dependencies": {
    "q": "~0.9.2",
    "collections": "~0.0.0"
  },
  "devDependencies": {
    "jasmine-node": "*",
    "cover": "*",
    "opener": "*"
  },
  "scripts": {
    "test": "jasmine-node spec",
    "cover": "cover run node_modules/jasmine-node/bin/jasmine-node spec && cover report html && opener cover_html/index.html"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/kriskowal/q-connection.git"
  },
  "engines": {
    "node": ">=0.2.0",
    "jetpack": ">=0.9.0"
  },
  "readme": "[![Build Status](https://secure.travis-ci.org/kriskowal/q-comm.png)](http://travis-ci.org/kriskowal/q-comm)\n\nAsynchronous Remote Objects\n---------------------------\n\nThis library makes it possible for objects to communicate\nasynchronously between memory-isolated JavaScript contexts,\nincluding pipelining interactions with results.  Promises\nserve as proxies for remote objects.\n\nQ-Comm works in Node and other CommonJS module loaders like\n[Browserify][], [Mr][], and [Montage][].\n\n[Q]: https://github.com/kriskowal/q\n[Browserify]: https://github.com/substack/node-browserify\n[Mr]: https://github.com/kriskowal/mr\n[Montage]: https://github.com/montagejs/montage\n\nThis is how it looks:\n\n```javascript\nvar Q = require(\"q\");\nvar Connection = require(\"q-comm\");\nvar remote = Connection(port, local);\n```\n\nThe ``remote`` object is a promise for the ``local`` object\non the other side of the connection.  Likewise, the other\nside of the connection will get a promise for your ``local``\nobject.  You are not obliged to provide a local object,\ndepending on which end of the connection is providing a\nservice.\n\nIf the ``remote`` or ``local`` object is not serializable,\nlike functions or objects with methods, the other side will\nreceive a promise but you will have to “send messages” to\nthe promise instead of interacting directly with the remote\nobject.  When you invoke a method on a remote object, you\nget a promise for the result and you can immediately\npipeline a method call on the result.  This is the secret\nsauce.\n\nThe ``port`` is any W3C message port, web worker, or web\nsocket.  In the W3C’s infinite wisdom, these do not have a\nunified API, but Q-Comm will normalize them internally.\n\n```javascript\n// To communicate with objects in a worker\nvar worker = new Worker(\"worker.js\");\nvar child = Connection(worker, local);\n```\n\n```javascript\n// Inside a worker, to communicate with the parent\nvar parent = Connection(this);\n```\n\n```javascript\n// To communicate with a remote object on the other side of\n// a web socket\nvar socket = new WebSocket(\"ws://example.com\");\nvar remote = Connection(socket, local);\n```\n\n```javascript\n// To communicate with a single frame on the same origin\n// (multiple frames will require some handshaking event sources)\nvar iframe = document.frames[0];\nvar child = Connection(iframe.contentWindow, local, {\n    origin: window.location.origin\n})\n```\n\n```javascript\n// To communicate with a parent frame on the same origin\nvar child = Connection(window, local, {\n    origin: window.location.origin\n})\n```\n\n```javascript\n// With a message port\nvar port = new MessagePort();\nvar near = Connection(port[0]);\nvar far = Connection(port[1]);\n```\n\nYour ``local`` value can be any JavaScript value, but it is\nmost handy for it to be an object that supports an API and\ncannot be serialized with JSON.\n\n```javascript\nvar Q = require(\"q\");\nvar counter = 0;\nvar local = {\n    \"next\": function () {\n        return counter++;\n    }\n};\n```\n\nIn this case, the local object has a \"next\" function that\nreturns incremental values.  Since the function closes on\nlocal state (the ``counter``), it can't be sent to another\nprocess.\n\nOn the other side of the connection, we can asynchronously\ncall the remote method and receive a promise for the result.\n\n```javascript\nremote.invoke(\"next\")\n.then(function (id) {\n    console.log(\"counter at\", i);\n});\n```\n\nThe connection is bi-directional.  Although you do not need\nto provide and use both ``local`` and ``remote`` values on\nboth sides of a connection, they are available.\n\nYou can asynchronously interact with any value using the Q\nAPI.  This chart shows the analogous operations for\ninteracting with objects synchronously and asynchronously.\n\n```\nsynchronous                asynchronous\n------------------         -------------------------------\nvalue.foo                  promise.get(\"foo\")\nvalue.foo = value          promise.put(\"foo\", value)\ndelete value.foo           promise.del(\"foo\")\nvalue.foo(...args)         promise.post(\"foo\", [args])\nvalue.foo(...args)         promise.invoke(\"foo\", ...args)\nvalue(...args)             promise.fapply([args])\nvalue(...args)             promise.fcall(...args)\n```\n\nAll of the asynchronous functions return promises for the\neventual result.  For the asynchronous functions, the value\nmay be any value including local values, local promises, and\nremote promises.\n\nThe benefit to using the asynchronous API when interacting\nwith remote objects is that you can send chains of messages\nto the promises that the connection makes.  That is, you can\ncall the method of a promise that has not yet been resolved,\nso that message can be immediately sent over the wire to the\nremote object.  This reduces the latency of interaction with\nremote objects by removing network round-trips.\n\nA chain of dependent operations can be contracted from:\n\n```\n<-client     server->\na..\n   ''--..\n         ''--..\n               ''--..\n             ..--''\n       ..--''\n ..--''\nb..\n   ''--..\n         ''--..\n               ''--..\n             ..--''\n       ..--''\n ..--''\nc..\n   ''--..\n         ''--..\n               ''--..\n             ..--''\n       ..--''\n ..--''\n```\n\nDown to:\n\n```\n<-client     server->\na..\nb..''--..\nc..''--..''--..\n   ''--..''--..''--..\n         ''--..--''..\n       ..--''..--''..\n ..--''..--''..--''\n ..--''..--''\n ..--''\n```\n\nWhere the dotted lines represent messages traveling through\nthe network horizontally, and through time vertically.\n\n\nPorts\n-----\n\nQ-Comm handles a variety of message ports or channel types.  They are\nall internally converted into a Q Channel.  If you are using a message\nchannel that provides a different API than this or a WebWorker,\nWebSocket, or MessagePort, you can adapt it to any of these interfaces\nand Q-Comm will handle it.\n\nThis is probably the simplest way to create a channel duck-type,\nassuming that you’ve got a connection instance of the Node variety.\n\n```javascript\nvar port = {\n    postMessage: function (message) {\n        connection.send(message);\n    },\n    onmessage: null // gets filled in by Q-Comm\n};\nconnection.on(\"message\", function (data) {\n    port.onmessage({data: \"\"})\n});\nvar remote = Connection(port, local);\n```\n\n## Q Channels\n\n-   ``get()`` returns a promise for the next message from the other\n    side of the connection.  ``get`` may be called any number of times\n    independent of when messages are actually received and each call\n    will get a promise for the next message in sequence.\n-   ``put(message)`` sends a message to the remote side of the\n    connection.\n-   ``close(reason_opt)`` indicates that no further messages will be\n    sent.\n-   ``closed`` a promise that is fulfilled with the reason for closing.\n\nQ-Comm exports an indefinite ``Queue`` that supports this API which\ngreatly simplifies the implementation of adapters.\n\n-   ``get()`` returns a promise for the next value in order that is\n    put on the queue.  ``get`` may be called any number of times,\n    regardless of whether the corresponding value is put on the queue\n    before or after the ``get`` call.\n-   ``put(value)`` puts a message on the queue.  Any number of\n    messages can be put on the queue, indepent of whether and when the\n    corresponding ``get`` is called.\n-   ``close(reason_opt)`` indicates that no further messages will be\n    put on the queue and that any promises for such messages must be\n    rejected with the given reason.\n-   ``closed`` a promise that is fulfilled when and if the queue has\n    been closed.\n\n## Web Workers and Message Ports\n\nQ-Comm detects ports by their ``postMessage`` function.\n\n-   ``postMessage(message)``\n-   ``onmessage(handler(message))``\n\n## Web Sockets\n\nQ-Comm detects Web Sockets by their ``send`` function.  It takes the\nliberty to start the socket and listens for when it opens.\n\n-   ``send(message)``\n-   ``addEventListener(event, handler(event))``\n-   ``start()``\n-   ``open`` event\n-   ``close`` event\n\nMemory\n------\n\nQ-Comm uses an LRU cache of specified size.  The default size is\ninfinite, which is horribly leaky.  Promises between peers will stick\naround indefinitely.  This can be trimmed to something reasonable with\nthe ``max`` option.\n\n```javascript\nvar remote = Connection(port, local, {max: 1024});\n```\n\nThe least frequently used promises will be collected.  If the remote\nattempts to communicate with a collected promise, the request will be\nrejected.  This is fine if you have code in place to recover from\nrejections that will revive the working set of promises.  The minimum\nworking set will vary depending on the load on your service.\n\n",
  "readmeFilename": "README.md",
  "_id": "q-connection@0.5.3",
  "_shasum": "a9f9457287e1a4946f4460a32543d066016a046f",
  "_from": "q-connection@0.5.3",
  "_resolved": "https://registry.npmjs.org/q-connection/-/q-connection-0.5.3.tgz"
}
